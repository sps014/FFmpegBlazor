var T=Object.defineProperty,U=(i,e,t)=>e in i?T(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,a=(i,e,t)=>(U(i,typeof e!="symbol"?e+"":e,t),t),b=(i,e,t)=>{if(!e.has(i))throw TypeError("Cannot "+t)},r=(i,e,t)=>(b(i,e,"read from private field"),t?t.call(i):e.get(i)),R=(i,e,t)=>{if(e.has(i))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(i):e.set(i,t)},I=(i,e,t,s)=>(b(i,e,"write to private field"),s?s.call(i,t):e.set(i,t),t),o;(function(i){i.LOAD="LOAD",i.EXEC="EXEC",i.WRITE_FILE="WRITE_FILE",i.READ_FILE="READ_FILE",i.DELETE_FILE="DELETE_FILE",i.RENAME="RENAME",i.CREATE_DIR="CREATE_DIR",i.LIST_DIR="LIST_DIR",i.DELETE_DIR="DELETE_DIR",i.ERROR="ERROR",i.DOWNLOAD="DOWNLOAD",i.PROGRESS="PROGRESS",i.LOG="LOG",i.MOUNT="MOUNT",i.UNMOUNT="UNMOUNT"})(o||(o={}));const y=(()=>{let i=0;return()=>i++})(),g=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),C=new Error("called FFmpeg.terminate()");var d,l,h,u,D,_,E;class k{constructor(){R(this,d,null),R(this,l,{}),R(this,h,{}),R(this,u,[]),R(this,D,[]),a(this,"loaded",!1),R(this,_,()=>{r(this,d)&&(r(this,d).onmessage=({data:{id:e,type:t,data:s}})=>{switch(t){case o.LOAD:this.loaded=!0,r(this,l)[e](s);break;case o.MOUNT:case o.UNMOUNT:case o.EXEC:case o.WRITE_FILE:case o.READ_FILE:case o.DELETE_FILE:case o.RENAME:case o.CREATE_DIR:case o.LIST_DIR:case o.DELETE_DIR:r(this,l)[e](s);break;case o.LOG:r(this,u).forEach(n=>n(s));break;case o.PROGRESS:r(this,D).forEach(n=>n(s));break;case o.ERROR:r(this,h)[e](s);break}delete r(this,l)[e],delete r(this,h)[e]})}),R(this,E,({type:e,data:t},s=[],n)=>r(this,d)?new Promise((c,w)=>{const p=y();r(this,d)&&r(this,d).postMessage({id:p,type:e,data:t},s),r(this,l)[p]=c,r(this,h)[p]=w,n?.addEventListener("abort",()=>{w(new DOMException(`Message # ${p} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(g)),a(this,"load",({classWorkerURL:e,...t}={},{signal:s}={})=>(r(this,d)||(I(this,d,e?new Worker(new URL(e,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-lPYB70QI.js",import.meta.url),{type:"module"})),r(this,_).call(this)),r(this,E).call(this,{type:o.LOAD,data:t},void 0,s))),a(this,"exec",(e,t=-1,{signal:s}={})=>r(this,E).call(this,{type:o.EXEC,data:{args:e,timeout:t}},void 0,s)),a(this,"terminate",()=>{const e=Object.keys(r(this,h));for(const t of e)r(this,h)[t](C),delete r(this,h)[t],delete r(this,l)[t];r(this,d)&&(r(this,d).terminate(),I(this,d,null),this.loaded=!1)}),a(this,"writeFile",(e,t,{signal:s}={})=>{const n=[];return t instanceof Uint8Array&&n.push(t.buffer),r(this,E).call(this,{type:o.WRITE_FILE,data:{path:e,data:t}},n,s)}),a(this,"mount",(e,t,s)=>{const n=[];return r(this,E).call(this,{type:o.MOUNT,data:{fsType:e,options:t,mountPoint:s}},n)}),a(this,"unmount",e=>{const t=[];return r(this,E).call(this,{type:o.UNMOUNT,data:{mountPoint:e}},t)}),a(this,"readFile",(e,t="binary",{signal:s}={})=>r(this,E).call(this,{type:o.READ_FILE,data:{path:e,encoding:t}},void 0,s)),a(this,"deleteFile",(e,{signal:t}={})=>r(this,E).call(this,{type:o.DELETE_FILE,data:{path:e}},void 0,t)),a(this,"rename",(e,t,{signal:s}={})=>r(this,E).call(this,{type:o.RENAME,data:{oldPath:e,newPath:t}},void 0,s)),a(this,"createDir",(e,{signal:t}={})=>r(this,E).call(this,{type:o.CREATE_DIR,data:{path:e}},void 0,t)),a(this,"listDir",(e,{signal:t}={})=>r(this,E).call(this,{type:o.LIST_DIR,data:{path:e}},void 0,t)),a(this,"deleteDir",(e,{signal:t}={})=>r(this,E).call(this,{type:o.DELETE_DIR,data:{path:e}},void 0,t))}on(e,t){e==="log"?r(this,u).push(t):e==="progress"&&r(this,D).push(t)}off(e,t){e==="log"?I(this,u,r(this,u).filter(s=>s!==t)):e==="progress"&&I(this,D,r(this,D).filter(s=>s!==t))}}d=new WeakMap,l=new WeakMap,h=new WeakMap,u=new WeakMap,D=new WeakMap,_=new WeakMap,E=new WeakMap;const S=new Error("failed to get response body reader"),P=new Error("failed to complete download"),W="Content-Length",v=async(i,e)=>{var t;const s=await fetch(i);let n;try{const c=parseInt(s.headers.get(W)||"-1"),w=(t=s.body)==null?void 0:t.getReader();if(!w)throw S;const p=[];let L=0;for(;;){const{done:f,value:m}=await w.read(),O=m?m.length:0;if(f){if(c!=-1&&c!==L)throw P;e&&e({url:i,total:c,received:L,delta:O,done:f});break}p.push(m),L+=O,e&&e({url:i,total:c,received:L,delta:O,done:f})}const A=new Uint8Array(L);let M=0;for(const f of p)A.set(f,M),M+=f.length;n=A.buffer}catch(c){console.log("failed to send download progress event: ",c),n=await s.arrayBuffer(),e&&e({url:i,total:n.byteLength,received:n.byteLength,delta:0,done:!0})}return n},B=async(i,e,t=!1,s)=>{const n=t?await v(i,s):await(await fetch(i)).arrayBuffer(),c=new Blob([n],{type:e});return URL.createObjectURL(c)};window.createFFmpeg=function(){return new k},window.load=async function(i,e){return console.log(i),await i.load(e)},window.toBlobURL=async function(i,e,t=!1,s=void 0){return await B(i,e,t,s)};
